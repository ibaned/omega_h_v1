#include <assert.h>
#include <stdio.h>

#include "edge_swap.h"
#include "files.h"
#include "ints.h"
#include "mark.h"
#include "mesh.h"
#include "loop.h"

int main()
{
  FILE* f = safe_fopen("edge_swap_edges.c", "w");
  fprintf(f,
      "/* AUTO-GENERATED by print_swap_edges.exe !\n"
      "   don't modify manually !\n\n"
      "   tables describing, for each possible triangulation\n"
      "   of an N-sided polygon, the interior edges of that\n"
      "   triangulation.\n\n"
      "   these will be used for full topology edge swapping\n"
      "   to create intermediate entities in the interior of the\n"
      "   cavity.\n\n"
      "   we don't bother identifying unique edges because no caching\n"
      "   is necessary for these intermediate entities */\n");
  fprintf(f, "\n#include \"edge_swap.h\"\n\n");
  unsigned nint_edges[MAX_EDGE_SWAP + 1] = {0};
  for (unsigned i = 4; i <= MAX_EDGE_SWAP; ++i) {
    unsigned nmeshes = swap_mesh_counts[i];
    for (unsigned j = 0; j < nmeshes; ++j) {
      struct mesh* m = new_mesh(2, MESH_REDUCED, 0);
      mesh_set_ents(m, 0, i, 0);
      unsigned ntris = swap_mesh_sizes[i];
      unsigned* conn = LOOP_MALLOC(unsigned, ntris * 3);
      for (unsigned k = 0; k < ntris; ++k) {
        unsigned tri = swap_meshes[i][j * ntris + k];
        for (unsigned l = 0; l < 3; ++l)
          conn[k * 3 + l] = swap_triangles[i][tri][l];
      }
      mesh_set_ents(m, 2, ntris, conn);
      unsigned* bdry_edges = mesh_mark_part_boundary(m);
      unsigned nedges = mesh_count(m, 1);
      if (nint_edges[i] == 0)
        nint_edges[i] = nedges - uints_sum(bdry_edges, nedges);
      else
        assert(nint_edges[i] == nedges - uints_sum(bdry_edges, nedges));
      fprintf(f, "LOOP_CONST static unsigned const edges_%u_%u[%u * 2] =\n{",
          i, j, nint_edges[i]);
      unsigned const* verts_of_edges = mesh_ask_down(m, 1, 0);
      unsigned l = 0;
      for (unsigned k = 0; k < nedges; ++k)
        if (!bdry_edges[k]) {
          if (l)
            fprintf(f, ",");
          fprintf(f, "%u,%u\n",
              verts_of_edges[k * 2 + 0],
              verts_of_edges[k * 2 + 1]);
          ++l;
        }
      fprintf(f, "};\n");
      loop_free(bdry_edges);
      free_mesh(m);
    }
  }
  for (unsigned i = 4; i <= MAX_EDGE_SWAP; ++i) {
    unsigned nmeshes = swap_mesh_counts[i];
    fprintf(f, "LOOP_CONST static unsigned const* const edges_%u[%u] =\n{",
        i, nmeshes);
    for (unsigned j = 0; j < nmeshes; ++j) {
      if (j)
        fprintf(f, ",");
      fprintf(f, "edges_%u_%u\n", i, j);
    }
    fprintf(f, "};\n");
  }
  fprintf(f, "LOOP_CONST unsigned const* const* const"
             " swap_int_edges[MAX_EDGE_SWAP + 1] =\n{");
  for (unsigned i = 0; i < 4; ++i) {
    if (i)
      fprintf(f, ",");
    fprintf(f, "0\n");
  }
  for (unsigned i = 4; i <= MAX_EDGE_SWAP; ++i)
    fprintf(f, ",edges_%u\n", i);
  fprintf(f, "};\n");
  fprintf(f, "LOOP_CONST unsigned const "
             "swap_nint_edges[MAX_EDGE_SWAP + 1] =\n{");
  for (unsigned i = 0; i <= MAX_EDGE_SWAP; ++i) {
    if (i)
      fprintf(f, ",");
    fprintf(f, "%u\n", nint_edges[i]);
  }
  fprintf(f, "};\n");
}
